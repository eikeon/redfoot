<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
   xmlns:redfoot="http://redfoot.net/2005/redfoot#"
   xmlns:server="http://redfoot.net/2005/server#"
>

  <server:Handler rdf:about="#">
    <rdfs:label>Default handler</rdfs:label>      
    <server:page_handler rdf:resource="../templates/classic#page"/>
    <server:unauthorized_page_handler rdf:resource="../templates/classic#unauthorized_page_handler"/>
    <server:display_support rdf:resource="#display_support"/>
    <rdf:value rdf:datatype="http://redfoot.net/2005/redfoot#Python"><![CDATA[

SERVER = redfoot.namespace("http://redfoot.net/2005/server#")

# Support tunneling requests for any resource through a server
if request.path.startswith("/;"):
    request.uri = URIRef(request.uri.split(";", 1)[-1]) 

# This was needed to fix a bug that happens fronting redfoot with apache via mod_proxy
if not "://" in request.uri:
    request.uri = URIRef(request.uri.replace(":/", "://"))

method = request.method.lower()
if method=="get" or method=="head":
    from twisted.web.http import datetimeToString, stringToDatetime, NOT_MODIFIED

    modified_since = request.getHeader('if-modified-since')
    if modified_since:
        try:
            modified_since = stringToDatetime(modified_since)
        except:
            modified_since = None

    last_modified = redfoot.value(request.uri, SERVER.last_modified)
    if last_modified:
        try:
            last_modified = int(last_modified)          
        except:
            last_modified = None

    if last_modified:
        response.setHeader("Last-Modified", datetimeToString(last_modified))

    if modified_since and last_modified and last_modified <= modified_since:
        response.setStatus(NOT_MODIFIED, "Not Modified")
        response.finish()
    else:
        handler = URIRef("#get_handler", base=redfoot_current)
        redfoot.execute(handler, context=globals())
elif method=="put":
    handler = URIRef("#put_handler", base=redfoot_current)
    redfoot.execute(handler, request=request, response=response)
elif method=="post":
    handler = URIRef("#get_handler", base=redfoot_current)
    redfoot.execute(handler, request=request, response=response)
else:
    response.setStatus(405, "Method Not Allowed")
    response.setHeader("ACCEPT", "HEAD")
    response.finish()
 ]]>
    </rdf:value>
  </server:Handler>

  <server:Handler rdf:about="#get_handler">
    <rdfs:label>Default GET handler</rdfs:label>      
    <server:page_handler rdf:resource="../templates/classic#page"/>
    <server:unauthorized_page_handler rdf:resource="../templates/classic#unauthorized_page_handler"/>
    <server:display_support rdf:resource="#display_support"/>
    <rdf:value rdf:datatype="http://redfoot.net/2005/redfoot#Python">
<![CDATA[

from twisted.internet.threads import deferToThread
from twisted.web.http import datetimeToString
from time import time

SERVER = redfoot.namespace("http://redfoot.net/2005/server#")

if (request.host, None, None) not in redfoot:
    redfoot.check(URIRef("aspects/auth", base=redfoot_program), publicID=URIRef("%s#auth_aspect" % request.host))
    redfoot.check(URIRef("aspects/generic", base=redfoot_program), publicID=URIRef("%s#generic_aspect" % request.host))
    redfoot.check(URIRef("aspects/edit_content", base=redfoot_program), publicID=URIRef("%s#edit_content_aspect" % request.host))
    redfoot.check(URIRef("aspects/contexts", base=redfoot_program), publicID=URIRef("%s#contexts_aspect" % request.host))


def lookup(property, default=None):
    return request.lookup(property) or redfoot.value(redfoot_current, property) or default

auth = redfoot.module(URIRef("modules/auth#module", base=redfoot_program))
allow = auth.allow

if not allow(request):
    page_handler = lookup(SERVER.unauthorized_page_handler)
    assert page_handler, "No 'unauthorized_page' found for: %s" % request.uri
else:
    page_handler = lookup(SERVER.page_handler)
    if page_handler is None:
        response.setStatus(404, "Not Found")            
        response.write("No page handler found")
        response.finish()

accept = request.headers.get("accept")
# TODO: check for best match
if accept and "application/rdf+xml" in accept:  
    if page_handler and (page_handler, SERVER.content_type, Literal("application/rdf+xml")) in redfoot:
        page_handler = page_handler
    else:
        page_handler = URIRef("#rdfxml_handler", base=redfoot_current)

response.cache_body = True # So that server's request.finish will add content-length, Content-MD5 and ETag headers

# TODO: if resource has last-modified then say so...
#response.setHeader("last-modified", datetimeToString(now))

# TODO: do at end of request processing?
response.setHeader("Cache-Control", "s-maxage=0, must-revalidate")
response.setHeader("Expires", datetimeToString(time()))
#response.setHeader("Vary", "Accept-Encoding")

redfoot.execute(lookup(SERVER.display_support), context=globals())

# TODO allow the long running assertion to be on the page_handler or page_part_handler as well?
long_running = redfoot.value(request.uri, SERVER.long_running)
if str(long_running)=="true": # TODO:
    def finish(_):
        response.finish()
    d = deferToThread(display, page_handler, fragment=False)
    d.addCallbacks(callback=finish, errback=finish)
else:
    display(page_handler, fragment=False)
    response.finish()

]]>
    </rdf:value>
  </server:Handler>


  <rdf:Description rdf:ID="display_support"> <!-- TODO: type-->
    <rdfs:label>display support</rdfs:label>      
    <rdf:value rdf:datatype="http://redfoot.net/2005/redfoot#Python">
<![CDATA[
# TODO: this is a bit out of hand :(

SERVER = redfoot.namespace("http://redfoot.net/2005/server#")
auth = redfoot.module(URIRef("modules/auth#module", base=redfoot_program))

def allow(uri):
    return auth.allow(request, uri)

import kid
from StringIO import StringIO
from itertools import chain

# redefine lookup
def lookup(property, default=None):
    return request.lookup(property) or redfoot.value(page_handler, property) or default

# special lookup for content
def lookup_content(property, default=None): 
    return lookup(property, default)

def display(uri, fragment=True, output=None, **args):
    if not uri:
        return
    request.sources.append(uri)
    assert(isinstance(uri, URIRef), "uri not URIRef as expected")
    context = globals()
    for k, v in args.items():
        context[k] = v
    redfoot.check(uri)
    global write_to_response
    if fragment==False:
        if not allow(uri):
            uri = lookup(SERVER.unauthorized_page_handler)
            assert uri, "No 'unauthorized_page' found for: %s" % uri
	write_to_response = True
	content_type = redfoot.value(uri, SERVER.content_type) or 'text/html; charset=UTF-8'
        if content_type=="application/xhtml+xml":
            content_type = "text/html" # For now don't worry about xhtml
        if "text/html" in content_type:
            output = "html-strict"
        else:
            output = "xml"
	response.setHeader('Content-Type', content_type)
    else:
        if not allow(uri):
            uri = lookup(SERVER.unauthorized_content_handler)
            assert uri, "No 'unauthorized_content' found for: %s" % uri
    value = redfoot.value(uri)
    if value and value.datatype==SERVER.Kid:
        t_mod = kid.load_template(StringIO(value.encode("utf-8")))
	t = t_mod.Template(**context)                  
	if write_to_response:
	    write_to_response = False
            try:
                t.write(response, encoding="utf-8", fragment=fragment, output=output or "xml")
            except Exception, e:
                redfoot.log.exception("While trying to display %s (%s) the following exception occurred:\n" % (redfoot.label(uri), uri))
            request.sources.pop()
	else:
            def pop():
                request.sources.pop()
                if False:
                    yield None
	    return chain(t, pop())
    else:
	write_to_response = True
	redfoot.execute(uri, **context) # TODO: think we want context=context?
        request.sources.pop()
]]>
    </rdf:value>
  </rdf:Description>

  <server:Handler rdf:about="#rdfxml_handler">
    <rdfs:label>Default RDF/XML handler</rdfs:label>      
    <rdf:value rdf:datatype="http://redfoot.net/2005/redfoot#Python">
<![CDATA[

response.setHeader('Content-Type', 'application/rdf+xml')            
cid = request.uri.abstract()
if (cid, RDF.type, REDFOOT.Context) in redfoot:
    base = None
else:
    cid = redfoot.context_id(cid) # default context
    base = redfoot.context_id(cid, context_id="") # TODO: basically defrag... need better way
context = redfoot.get_context(cid)
context.serialize(destination=response, base=base)
# NOTE: serialize calls close on response. So we should not call: response.finish() 

]]>
    </rdf:value>
  </server:Handler>


  <server:Handler rdf:about="#put_handler">
    <rdfs:label>Default GET handler</rdfs:label>      
    <server:page_handler rdf:resource="../templates/classic#page"/>
    <server:unauthorized_page_handler rdf:resource="../templates/classic#unauthorized_page_handler"/>
    <server:display_support rdf:resource="#display_support"/>
    <rdf:value rdf:datatype="http://redfoot.net/2005/redfoot#Python">
<![CDATA[

auth = redfoot.module(URIRef("modules/auth#module", base=redfoot_program))
uid = auth.authenticate(request)
if uid and uid in request.objects(REDFOOT.admin):
    cid = request.uri.abstract()
    if not (cid, RDF.type, REDFOOT.Context) in redfoot:
        cid = redfoot.context_id(cid) # default context
    redfoot.remove_context(cid)
    context = redfoot.get_context(cid, creator=uid)
    base = redfoot.context_id(cid, context_id="") # TODO: basically defrag... need better way.
    context.parse(request.content, publicID=base)
else:
    response.setStatus(401, "Not Authorized")            
    response.setHeader("WWW-Authenticate", "Basic realm='default'")
response.finish()

]]>
    </rdf:value>
  </server:Handler>

</rdf:RDF>  
