<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
   xmlns:rdfe="http://redfoot.net/3.0/rdf#"
   xmlns:code="http://redfoot.net/3.0/code#"
   xmlns:command="http://redfoot.net/3.0/command#"
   xmlns:kernel="http://redfoot.net/3.0/kernel#"
>
  <rdfs:Resource rdf:ID="Globals">
    <rdfs:label>Redfoot Globals</rdfs:label>
    <rdfs:comment></rdfs:comment>
  </rdfs:Resource>

  <rdf:Property rdf:ID="persona">
    <rdfs:label>persona</rdfs:label>
    <rdfs:comment>The identity the Kernel is to use to personify itself</rdfs:comment>
    <rdfs:range rdf:resource="#Kernel"/>
  </rdf:Property>

  <rdfs:Class rdf:ID="Admin">
    <rdfs:label>Kernel Admin</rdfs:label>
    <rdfs:comment></rdfs:comment>
    <rdfs:subClassOf rdf:resource="kernel#Resource"/>
  </rdfs:Class>

  <rdfs:Class rdf:ID="Program">
    <rdfs:label>Kernel Program</rdfs:label>
    <rdfs:comment></rdfs:comment>
    <rdfs:subClassOf rdf:resource="code#Code"/>
  </rdfs:Class>

  <rdfs:Class rdf:ID="OnLoad">
    <rdfs:label>Kernel OnLoad Handler</rdfs:label>
    <rdfs:comment></rdfs:comment>
    <rdfs:subClassOf rdf:resource="code#Code"/>
  </rdfs:Class>

  <rdf:Description rdf:about="#">
    <code:python rdf:datatype="redfoot#Python">
<![CDATA[

import redfootlib
import logging, sys

_logger = logging.getLogger()

redfootlib_version = tuple([int(x) for x in redfootlib.__version__.split(".", 2)])    

REDFOOTLIB_MINIMUM = (2, 7, 0)

if redfootlib_version < REDFOOTLIB_MINIMUM:
    _logger.warning("This version of the redfoot kernel is still in development.")
    _logger.critical("This kernel requires redfootlib %s or greater. Found redfootlib version %s. easy_install -U redfoot==dev" % ("%s.%s.%s" % REDFOOTLIB_MINIMUM, redfootlib.__version__))
    _logger.warning("If you wish to keep running with redfoot 2.1.x please run: redfoot --program=https://svn.redfoot.net/branches/2.1/kernel# --set-default")
    sys.exit(-1)

]]>
    </code:python>
  </rdf:Description>

  <code:Module rdf:ID="module">
    <rdfs:label>Redfoot Kernel</rdfs:label>
    <rdfs:comment>
    </rdfs:comment> 
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[

# TODO: put in check that this is being run with boot#loader ?  

import sys, logging
from datetime import datetime
from urlparse import urldefrag
from itertools import chain

from rdflib import URIRef, Literal, BNode
from rdflib import RDF, RDFS
from rdflib.Graph import Graph, ConjunctiveGraph
from rdflib.Namespace import NamespaceDict as Namespace 
from rdflib.Journal import JournalReader, JournalWriter
from rdflib.events import Dispatcher, Event
from rdflib import TextIndex

# To work around rdflib 2.4.0's TextIndex indexing base64binary like
# crazy... only index on word boundaries for now.
import re
TextIndex.word_pattern = re.compile(r"(?u)\S+")

_logger = logging.getLogger("hypercode.%s" % redfoot_loader.label(__uri__))

KERNEL = Namespace(URIRef("http://redfoot.net/3.0/kernel#"))
RDFE = Namespace(URIRef("http://redfoot.net/3.0/rdf#"))
CODE = Namespace(URIRef("http://redfoot.net/3.0/code#"))
DCTERMS = Namespace(URIRef("http://purl.org/dc/elements/1.1/"))
DC = Namespace(URIRef("http://purl.org/dc/terms/"))


class Kernel(ConjunctiveGraph):

    def __init__(self, store):
        super(Kernel, self).__init__(store) 
        self.uri = __uri__ # uri to the version of redfoot that's running
        self.__index = None
	self.__base = None 
        self.__uri_map = set()
        self.__namespaces = {}
        self.dispatcher = Dispatcher()
        self.xmpp = None
        self.__globals = None
        self.__text_index = None
        self.map(URIRef("http://xmlns.com/foaf/0.1/"), URIRef("http://xmlns.com/foaf/0.1/index.rdf"))
        
    def _get_crypto(self):
        try:
            return redfoot_loader.crypto
        except NoCryptoSupport, e:
            _logger.warning("No Crypto Support... flying in the clear!")
            class Crypto(object):
                def encrypt(self, value):
                    return value
                def decrypt(self, value):
                    return value
            return Crypto()
    crypto = property(_get_crypto, doc="object with crypto methods")

    def __get_base(self):
        if self.__base is None:
            self.__base = self.value(KERNEL.Globals, KERNEL.base)
            if self.__base is None:
                self.__base = self.absolutize("")
        return self.__base

    def __set_base(self, base):
	self.index.set((KERNEL.Globals, KERNEL.base, base))

    base = property(__get_base, __set_base)

    def __get_text_index(self):
        if self.__text_index is None:
            self.__text_index = TextIndex.TextIndex(store="Sleepycat")
            self.__text_index.open("redfoot-text_index", create=True)
            self.__text_index.subscribe_to(self)
            self.__text_index.link_to(self)
        return self.__text_index
    text_index = property(__get_text_index)

    def open(self, path, rebuild=False):
        _logger.debug("opening with store=%s and configuration=%s" % (self.store, path))
        if rebuild==True:    
            _logger.info("rebuilding store from journal file...")
            os.rename(path, "%s-backup-%s" % (path, date_time()))
            self.open(path)
            JournalReader(self.store, "%s-journal" % path)
            self.close()
            _logger.info("done rebuilding.")
        journal = JournalWriter(self.store, filename="%s-journal" % path) 
        super(Kernel, self).open(path, create=True)
        self.text_index # so that we hook up the text indexing... may want to move this, but for now hard code it here
        onLoadHandlers = []
        for uri in self.instances(KERNEL.OnLoad):
            rank = self.value(uri, KERNEL.onLoadRank) or 0
            onLoadHandlers.append((rank, uri))
        onLoadHandlers.sort()
        _logger.info("TODO: replace onLoadRank with info about which depend on which. a depends on b, etc.")
        _logger.debug("onLoadHandlers: %s" % onLoadHandlers)
        for rank, uri in onLoadHandlers:
            try:
                self.execute(uri, redfoot=self)
            except Exception, e:
                _logger.info("While trying to execute %s" % uri)
                _logger.exception(e)


    def _get_globals(self):
        if self.__globals is None:
            self.__globals = {"redfoot": self, 
                              "RDF": RDF, "RDFS": RDFS,
#"REDFOOT": self.namespace("http://redfoot.net/"), 
#"BNode": BNode, 
                              "URIRef": URIRef, "Literal": Literal}
        return self.__globals
    globals = property(_get_globals)

    def __get_index(self):
        if self.__index is None:
            self.__index = Graph() # To stop recursion
            self.__index = self.get_context(URIRef("#index", base=__uri__), creator=__uri__)
        return self.__index

    index = property(__get_index, doc="context where redfoot stores data about contexts")
            
    def get_context(self, identifier, creator=None):
        """ Returns a Context graph for the given identifier, which
        must be a URIRef or BNode."""
        result = Graph(store=self.store, identifier=identifier, namespace_manager=self)
        self.index.remove((identifier, RDF.type, KERNEL.DeletedContext))
        self.index.add((identifier, RDF.type, KERNEL.Context))
        if creator and not (identifier, DCTERMS.creator, None) in self.index:
            self.index.add((identifier, DCTERMS.creator, creator))
        if (identifier, DC.created, None) not in self.index:
            self.index.add((identifier, DC.created, Literal(datetime.utcnow())))
        return result

    def remove_context(self, context):
        """removes both the context and metadata about the context."""
        if isinstance(context, URIRef) or isinstance(context, BNode):
            context = self.get_context(context)
        self.index.remove((context.identifier, None, None))
        self.index.add((context.identifier, RDF.type, KERNEL.DeletedContext))        
        super(Kernel, self).remove_context(context)

    def map(self, logical, physical):
        """Map all URIRefs starting with logical to corresponding ones starting with physical."""
        _logger.info("mapping %s -> %s" % (logical, physical))
        # TODO: sanity checks
        self.__uri_map.add((logical, physical))

    def physical(self, uri):
        "Concert from logical uri to physical uri"
        for logical, physical in self.__uri_map:
            if uri.startswith(logical):
                return URIRef(uri.replace(logical, physical, 1))
        return uri

    def logical(self, uri):
        "Concert from physical uri to logical uri"
        for logical, physical in self.__uri_map:
            if uri.startswith(physical):
                return URIRef(uri.replace(physical, logical, 1))
        return uri

    def check(self, uri, creator=None):
        """
        Checks to see if redfoot knows anything about uri

        Currently, if not, Kernel will attempt to load from uri.
        """
        if isinstance(uri, URIRef):
            _logger.debug("checking %s" % uri)
            location = uri.defrag()
            context_uri = self.context_id(location)
            if not (context_uri, RDF.type, KERNEL.Context) in self.index: 
                # request the context so it gets created thus avoiding recursion
                self.get_context(context_uri, creator=creator)
                try:
                    self.load(location, creator=creator)
                except Exception, e:
                    _logger.warning("couldn't load %s while checking: %s\n" % (uri, e))
        else: 
            _logger.warning("%r is not an instance of rdflib.URIRef\n" % uri)
            raise ValueError("wrong type")
        return (uri, None, None) in self

    def load(self, location, format="xml", publicID=None, creator=None, scutter=False):
        """
        location is a relative or absolute URI
        publicID if specified will override location as the xml:base
        contextID
        """
        if "#" in location:
            location = URIRef(urldefrag(location)[0])
        location = self.physical(location)
        publicID = publicID or self.absolutize(location)
        publicID = self.absolutize(publicID, defrag=False)
        publicID = self.logical(publicID)
        context_id = self.context_id(publicID)
        context = self.get_context(context_id, creator=creator)

        absolute_location = self.absolutize(location)
        context.remove((None, None, None))

        logical = self.logical(location)
        _logger.info("loading: %s" % logical)
        if logical!=location:
            _logger.info("   from: %s" % location)

        context.load(absolute_location, publicID=publicID, format=format)

        self.index.remove((context_id, RDFE.source, None))
        self.index.add((context_id, RDFE.source, location))
        self.index.remove((context_id, RDFE.publicID, None))        
        self.index.add((context_id, RDFE.publicID, publicID))
        if (context_id, RDFS.label, None) not in self:
            label = self.label(URIRef("#", base=publicID))
            if label:
                self.index.add((context_id, RDFS.label, label))
        if format=="xml":
            self.index.add((publicID.defrag(), RDF.type, URIRef("http://redfoot.net/3.0/rdf#RDFXMLDocument")))
        return context

    def module(self, uri, check_cache=True):
        if not isinstance(uri, URIRef):
            uri = URIRef(uri)
        self.check(uri)
        module_name = uri

        if check_cache:
            module = sys.modules.get(module_name, None)
            if module:
                return module
        _logger.info("creating module for: %s" % uri)

        import types

        safe_module_name = "__uri___%s" % hash(uri)
        module = types.ModuleType(safe_module_name)
        module.__name__ = module_name 
        module.__file__ = uri
        module.__ispkg__ = 0
        sys.modules[module_name] = module
        module.__dict__.update(self.globals)
        self.execute(uri, context=module.__dict__)
        return module
#         _logger.debug("creating module: %s" % this.__uri__)
#         module_name = this.__uri__       
#         if (uri, RDF.type, CODE.PythonModule) not in self:
#             _logger.warning("%r not of type CODE.PythonModule" % uri)
#         this = self.instance(uri, type=CODE.PythonModule)
#         return this

    def instance(self, uri, type=None):
        class Object(object):
            def __repr__(self):
                return "<Redfoot Module %s %s>" % (id(self), dir(self))

        this = Object()
        this.execute = self.execute
        this.__uri__ = uri
        if type:
            types = [type]
        else:
            types = self.objects(uri, RDF.type)
        for type in types:
            constructor = self.value(type, CODE.constructor)
            if constructor is None:
                raise ValueError("Didn't find constructor for %s" % type)
            self.execute(constructor, this=this)
        return this
        
    def execute(self, uri, context=None, **args):
        if self.check(uri):
            if CODE.Code not in self.types(uri):
                _logger.warning("%s not of type CODE.Code" % uri)
                _logger.debug("  types: %s" % list(self.types(uri)))
            for other in self.objects(uri, RDFS.seeAlso):
                self.check(other)
            value = self.value(uri, CODE.python)
            if value is None:
                raise Exception("Couldn't execute %s (has no CODE.python)" % uri)
            if context==None:
                context = dict(self.globals)
            for k, v in args.items():
                context[k] = v
            context["__uri__"] = uri

            from types import CodeType
            if isinstance(value, CodeType):
                _logger.info("Wheeee: %s", uri)
                exec value in context
            else:
                value = value.replace("\r\n", "\n")        
                value = value.replace("\r", "\n")        
                c = compile(value+"\n", uri, "exec")
                exec c in context
            return context
        else:
            raise Exception("Couldn't execute %s (nothing known about resource)" % uri)

    def context_id(self, uri, context_id=None):
        """ URI#context """
        uri, frag = urldefrag(uri)
        frag = context_id or frag or "context"
        if frag.startswith("#"):
            frag = frag[1:]
        if uri.endswith("/"):
            uri = uri[:-1]
        return URIRef("%s#%s" % (uri, frag))

    def namespace(self, uri, creator=None, context=None):
        uri = URIRef(uri)
        namespace = self.__namespaces.get(uri)
        if namespace is None:
            if context is None:
                self.check(uri, creator=creator)
                context_uri = self.context_id(uri)            
                context = self.get_context(context_uri, creator=creator)            
            namespace = Namespace(uri, context)
            self.__namespaces[uri] = namespace
        return namespace

    def bind(self, prefix, namespace, override=True):
        """
        Override Graphs bind to additionally declare the namespace to
        be of RDF.type RDFE.Namespce. And to load it if it's not
        already been loaded.
        """
        namespace = URIRef(namespace)
        if not (namespace, RDF.type, RDFE.Namespace) in self.index:
            try:
                self.check(namespace)
            except Exception, e:
                _logger.exception(e)
            self.index.add((namespace, RDF.type, RDFE.Namespace))
        super(Kernel, self).bind(prefix, namespace, override)


    def write(self, s, encoding="utf-8"):
        sys.stdout.write(s.encode(encoding))

    def subclasses(self, uri, direct=True):
        """
        Applies brute force RDFS entailment to infer additional classification 
        """
        if uri==RDFS.Resource:
            # TODO: direct=False
            for subclass in self.subjects(RDF.type, RDFS.Class):
                for c in self.objects(subclass, RDFS.subClassOf):
                    if c==RDFS.Resource or not (c, RDF.type, RDFS.Class) in self:
                        yield subclass
                        break
            return
        if direct==True:
            for subclass in self.subjects(RDFS.subClassOf, uri):
                yield subclass
        else:
            seen = set()
            for subclass in self.transitive_subjects(RDFS.subClassOf, uri):
                if subclass not in seen:
                    seen.add(subclass)
                    yield subclass

    def instances(self, uri):
        seen = set()
        for instance in self.subjects(RDF.type, uri):
            if instance not in seen:
                seen.add(instance)
                yield instance
        for subclass in self.subclasses(uri, direct=False):
            for instance in self.subjects(RDF.type, subclass):
                if instance not in seen:
                    seen.add(instance)
                    yield instance

    def types(self, subject):
	"""
        generator over the types of subject ordered from most specific to least
        Applies brute force RDFS entailment to infer additional classification
        """
	seen = set()
	l = []
	for type in self.objects(subject, RDF.type):
	    for t in self.transitive_objects(type, RDFS.subClassOf):
		num = len(list(self.transitive_objects(t, RDFS.subClassOf)))
		if t not in seen:
		    seen.add(t)
		    l.append((num, t))
        if isinstance(subject, URIRef):
            for type in self.objects(subject.abstract(), RDF.type):
                for t in self.transitive_objects(type, RDFS.subClassOf):
                    num = len(list(self.transitive_objects(t, RDFS.subClassOf)))
                    if t not in seen:
                        seen.add(t)
                        l.append((num, t))
	l.sort()
	l.reverse()
	for num, type in l:
	    yield type

    def possible_properties(self, type):
	for object in self.transitive_objects(type, RDFS.subClassOf):
	    for subject in self.subjects(RDFS.domain, object):
		for property in self.transitive_subjects(RDFS.subPropertyOf, subject): 
		    yield property

    def possible_properties_for_subject(self, subject):
	seen = set()
	for type in chain([RDFS.Resource], self.objects(subject, RDF.type)):
	    for property in self.possible_properties(type):
		if not property in seen:
		    seen.add(property)
		    yield property

    def getLogger(self, uri):
        return logging.getLogger("hypercode.%s" % self.label(uri) or uri)

]]>
    </code:python>
  </code:Module>

  <kernel:Program rdf:ID="runner">
    <rdfs:label>Command Runner</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[

import logging

_logger = logging.getLogger(__uri__)

CODE = redfoot.namespace(URIRef("http://redfoot.net/3.0/code#"))
COMMAND = redfoot.namespace(URIRef("http://redfoot.net/3.0/command#"))


commands = {}

for command in redfoot.instances(COMMAND.Command):
    redfoot.check(command)
    label = redfoot.label(command)
    commands[label] = command

# TODO: command line parsing and usage
if not args:
    args = [""]

command = args[0]

# find code object by label or full URIRef
code = commands.get(command, URIRef(command))
if code:
    redfoot.execute(code, stdout=redfoot, stderr=redfoot, args=args[1:])
else:
    if command:
        redfoot.write("Command '%s' not found.\n" % command)
    command_list = commands.keys()
    command_list.sort()
    redfoot.write("available commands: \n    %s\n" % ", ".join(command_list))

]]>
    </code:python>
  </kernel:Program>

  <command:Command rdf:ID="load">
    <rdfs:label>load</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[

if len(args)==0 or len(args)>3:
    print "usage: ./redfoot.py load <uri> [<publicID>]"
else:
    import os
    from urllib import pathname2url
    from urlparse import urljoin
    url = URIRef(args[0], base="%s/" % urljoin("file:", pathname2url(os.getcwd())))
    try:
        publicID = URIRef(redfoot.absolutize(args[1], defrag=False))
    except:
        publicID = None
    print "loading: %s" % url
    if publicID:
        print " with publicID: %s" % publicID
    redfoot.load(url, publicID=publicID, creator=__uri__)

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="run_tests">
    <rdfs:label>run_tests</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[

_logger = redfoot.getLogger(__uri__)

from optparse import OptionParser
parser = OptionParser("""This command is for running tests on hypercode.""")

try:
    options, args = parser.parse_args(args)
except SystemExit, e:
    pass
else:
    for uri, _, value in redfoot.triples((None, RDF.value, None)):
        if isinstance(value, Literal):
            _logger.warning("%s has an old RDF.value of datatype REDFOOT.Python" % uri)

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="update_text_index">
    <rdfs:label>update_text_index</rdfs:label>
    <code:python rdf:datatype="redfoot#Python">
<![CDATA[

from optparse import OptionParser
parser = OptionParser("""
Update the text index""")

try:
    options, args = parser.parse_args(args)
except SystemExit, e:
    pass
else:
    redfoot.text_index.index_graph(redfoot)

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="set_base">
    <rdfs:label>set_base</rdfs:label>
    <code:python rdf:datatype="redfoot#Python">
<![CDATA[

from optparse import OptionParser
parser = OptionParser("""
This command is for adding a Redfoot user and expects one argument, the user identifier.""")
parser.add_option("--password", dest="password", help="password for the admin being added")
parser.add_option("--xmpp_id", dest="xmpp_id", help="xmpp_id for the admin being added")

try:
    options, args = parser.parse_args(args)
    done = False
except SystemExit, e:
    done = True
#else:
if not done:

    if len(args)==1:
        redfoot.base = URIRef(args[0])
        stdout.write("kernel base set to %s\n" % redfoot.base)
    else:
        stdout.write("No base identifier specified.\n")
        parser.print_help()

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="user_add">
    <rdfs:label>user_add</rdfs:label>
    <rdfs:comment>Example: 

redfoot add_user eikeon@eikeon.com --password --digest-only --id=/users/user/eikeon# --full-name="Daniel Krech"

    </rdfs:comment>
      <code:python rdf:datatype="redfoot#Python">
<![CDATA[

from getpass import getpass
from optparse import OptionParser
import sha

_logger = redfoot.getLogger(__uri__)

KERNEL = redfoot.namespace("http://redfoot.net/3.0/kernel#")
USER = redfoot.namespace("http://redfoot.net/3.0/user#")
FOAF = redfoot.namespace("http://xmlns.com/foaf/0.1/")
XMPP = redfoot.namespace("http://redfoot.net/3.0/xmpp#")

parser = OptionParser("""This command is for adding a Redfoot user and expects one argument, the user@host.""")
parser.add_option("--full-name", dest="full_name", help="full name of user being added")
parser.add_option("--password", dest="password", help="password for the user being added")
parser.add_option("--digest-only", dest="digest_only", action="store_true", 
                  help="""Only store digests of password. Otherwise also stores an encrypted version of the password as well.""")
parser.add_option("--xmpp_id", dest="xmpp_id", help="add additional xmpp_id")
parser.add_option("--admin", dest="admin", action="store_true", help="add additional xmpp_id")
parser.add_option("--kernel", dest="kernel", action="store_true", help="persona of kernel")


parser.set_defaults(password=None)

try:
    options, args = parser.parse_args(args)
except SystemExit, e:
    pass
else:
    if len(args)==1:
        username, hostname = args[0].split("@", 1)
        uri = URIRef("/users/%s#" % username, base=redfoot.base)
        c = redfoot.get_context((URIRef("#context", base=uri)), creator=__uri__)
        full_name = options.full_name or username
        c.add((uri, RDFS.label, Literal(full_name)))
        c.add((uri, RDF.type, USER.User))
        c.add((uri, FOAF.mbox, URIRef("mailto:%s@%s" % (username, hostname))))
        c.add((uri, XMPP.uid, URIRef("xmpp:%s@%s" % (username, hostname))))
        if options.admin:
            c.add((uri, RDF.type, KERNEL.Admin))
        if options.kernel:
            c.set((redfoot.uri, KERNEL.persona, uri))
        if options.xmpp_id:
            xmpp_id = options.xmpp_id
            if not xmpp_id.startswith("xmpp:"):
                xmpp_id = "xmpp:%s" % xmpp_id
            c.add((uri, XMPP.uid, URIRef("%s" % xmpp_id)))
        if options.password is not None:
            if options.password=="":
                password = getpass("password:")
            try:
                e = redfoot.crypto.encrypt(password)
            except Exception, e:
                _logger.warning("Couldn't store encrypted password: %s" % e)  
            else:
                from base64 import b64encode, b64decode
                base64Binary = URIRef("http://www.w3.org/2001/XMLSchema#base64Binary")
                value = Literal(b64encode(e), datatype=base64Binary)
                _logger.info("%r" % value)
                ee = b64decode(value)
                assert ee==e, "%r!=%r" % (ee, e)
                c.set((uri, USER.encrypted_password, value))
            password = Literal(password.strip())
            hexdigest = Literal(sha.new(password).hexdigest())
            c.set((uri, USER.hexdigest, hexdigest))
        _logger.debug("\nassertions added:\n%s" % c.serialize(format="n3"))
        stdout.write("added user with identifier '%s'\n" % uri)
    else:
        stdout.write("%prog expects one argument, the user@host.\n")
        parser.print_help()

]]>
    </code:python>
  </command:Command>

  <kernel:OnLoad rdf:about="#xmpp_authentication">
    <kernel:onLoadRank rdf:datatype="http://www.w3.org/2001/XMLSchema#float">9.0</kernel:onLoadRank>
    <rdfs:label>XMPP Authentication</rdfs:label>
    <rdfs:comment></rdfs:comment>
    <code:python rdf:datatype="redfoot#Python">
<![CDATA[

_logger = redfoot.getLogger(__uri__)

KERNEL = redfoot.namespace("http://redfoot.net/3.0/kernel#")
USER = redfoot.namespace("http://redfoot.net/3.0/user#")
XMPP = redfoot.namespace("http://redfoot.net/3.0/xmpp#")

xmpp = redfoot.module(URIRef("http://redfoot.net/3.0/xmpp#client"))

persona = redfoot.value(redfoot.uri, KERNEL.persona)
if persona:
    xmpp_id = redfoot.value(persona, XMPP.uid)
    ep = redfoot.value(persona, USER.encrypted_password)
    if ep is None:
        raise Exception("no encrypted password")
    from base64 import b64decode
    xmpp_password = redfoot.crypto.decrypt(b64decode(ep))
    
    if xmpp_id and xmpp_password:
        redfoot.xmpp = xmpp.Client(xmpp_id, xmpp_password)

        import logging
        xmpp_logging = redfoot.module(URIRef("http://redfoot.net/3.0/xmpp#logging"))
        _root_logger = logging.getLogger()
        _xmpp_handler = xmpp_logging.XMPPHandler(KERNEL.Admin)
        _xmpp_formatter = logging.Formatter('[%(name)s] %(message)s')
        _xmpp_handler.setFormatter(_xmpp_formatter)
        _root_logger.addHandler(_xmpp_handler)

]]>
    </code:python>
  </kernel:OnLoad>

  <command:Command rdf:ID="test_module">
    <rdfs:label>test_module</rdfs:label>
    <code:python rdf:datatype="redfoot#Python">
<![CDATA[


]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="run">
    <rdfs:label>run</rdfs:label>
    <rdfs:comment>Run the twisted event loop</rdfs:comment>
    <code:python rdf:datatype="redfoot#Python">
<![CDATA[

_logger = redfoot.getLogger(__uri__)

_logger.info("Running twisted's event loop")

try:
    import twisted
except ImportError, e:
    raise ImportError("Twisted not installed. Please install Twisted-2.5.0 ( http://twistedmatrix.com/trac/#Downloading )")

from twisted.internet import reactor

try:
    try:
        reactor.run()
    except ValueError:
        reactor.run(installSignalHandlers=0)
except KeyboardInterrupt: # TODO: 
    _logger.info("Shutting down twisted's event loop")
    reactor.shutdown()

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="save">
    <rdfs:label>save</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[

RDFE = redfoot.namespace("http://redfoot.net/3.0/rdf#")

for arg in args:
    print "saveing: %s" % arg
    source = URIRef(redfoot.absolutize(arg))
    print "source:", source
    for cid, _, source in redfoot.index.triples((None, RDFE.source, source)):
        context = redfoot.get_context(cid)
        context.save(source, format="pretty-xml")
        print "saved:", source, len(context)

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="print">
    <rdfs:label>print</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[

import sys
for arg in args:
    cid = redfoot.absolutize(arg, defrag=0)
    print cid
    context = redfoot.get_context(cid)
    context.serialize(format="pretty-xml", destination=sys.stdout)

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="serialize">
    <rdfs:label>serialize</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[

_logger = redfoot.getLogger(__uri__)

import sys
from rdflib.Graph import Graph

prefix = redfoot.absolutize(args[0], defrag=0)
if len(args)>1:
    base = redfoot.absolutize(args[1])
else:
    base = prefix

out = Graph(namespace_manager=redfoot.namespace_manager)
for cid in redfoot.contexts():
    if cid.identifier.startswith(prefix):
        c = redfoot.get_context(cid.identifier)
        out += c  

out.serialize(destination=sys.stdout, base=base)

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="contexts">
    <rdfs:label>contexts</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[

RDFE = redfoot.namespace("http://redfoot.net/3.0/rdf#")

for context in redfoot.contexts():
    try:
        cid = context.identifier
        source = redfoot.index.value(cid, RDFE.source)
        if source is None or cid.startswith(source):
            redfoot.write(cid+"\n")
        else:
            print "%s\n   source: %s" % (cid, source) #, len(redfoot.get_context(cid))
    except Exception, e:
        print cid, e

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="remove_context">
    <rdfs:label>remove_context</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[

RDFE = redfoot.namespace("http://redfoot.net/3.0/rdf#")

for arg in args:
    if arg.startswith("_"):
        uri = BNode(arg[1:])
    else:
        uri = URIRef(redfoot.absolutize(arg, defrag=0))
    for context in redfoot.contexts():
        if uri== context.identifier:
            print "removing:", uri
            redfoot.remove_context(context) 
    for cid in redfoot.index.subjects(RDFE.source, uri):
        print "removing: %s\n    source: %s" % (cid, uri)
        redfoot.remove_context(redfoot.get_context(cid))

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="reload">
    <rdfs:label>reload</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[

RDFE = redfoot.namespace("http://redfoot.net/3.0/rdf#")

import logging

_logger = redfoot.getLogger(__uri__)

from optparse import OptionParser
parser = OptionParser("""
This command is for reloading all redfoot contexts that start with a prefix.""")
parser.add_option("--ignore-source", action="store_true", dest="ignore_source", help="ignore-source when reloading ")

try:
    options, args = parser.parse_args(args)
    done = False
except SystemExit, e:
    done = True

if not done:
    from rdflib import exceptions
 
    # usage reload all contexts starting with prefix (first arg)... defaults to all contexts
    try:
        prefix = args[0]
    except:
        prefix = ""
    prefix = redfoot.absolutize(prefix, defrag=False)

    DC_creator = URIRef("http://purl.org/dc/elements/1.1/creator")
    
    for context in redfoot.contexts():
        cid = context.identifier
        if cid.startswith(prefix):
            try:
                if options.ignore_source:
                    source = cid
                else:
                    source = redfoot.index.value(cid, RDFE.source)
            except exceptions.UniquenessError, e:
                _logger.warning("Multiple sources for %s: %s" % (cid, list(redfoot.objects(cid, RDFE.source))))
                source = None
            if source is not None:
                publicID = redfoot.index.value(cid, RDFE.publicID, any=True)
                if cid.startswith(source):
                    print "reloading: %s" % (cid,)
                else:
                    print "reloading: %s\n    source: %s" % (cid, source)
                redfoot.load(source, publicID=publicID)

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="save_all">
    <rdfs:label>save_all</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[

RDFE = redfoot.namespace("http://redfoot.net/3.0/rdf#")

for cid, _, source in redfoot.index.triples((None, RDFE.source, None)):
    if source:
        print "saving %s" % source
        try:
            context = redfoot.get_context(cid)
            context.save(source, format="pretty-xml")            
        except Exception, e:
            print e

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="auto_reload">
    <rdfs:label>auto_reload</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[
    
RDFE = redfoot.namespace("http://redfoot.net/3.0/rdf#")

DC = redfoot.namespace("http://purl.org/dc/elements/1.1/")

from time import sleep
from urlparse import urlparse
from os.path import getmtime, isfile

while 1:
    sleep(1)
    for cid, _, source in redfoot.index.triples((None, RDFE.source, None)):
        if source:
            scheme, netloc, path, params, query, fragment = urlparse(source)
            if isfile(path):
                ts = getmtime(path)                
		LONG_AGO = 0
                current_ts = float(redfoot.value(cid, DC.date, any=True, default=LONG_AGO))
                if not current_ts or current_ts<ts:
                    redfoot.remove((cid, DC.date, None))
                    redfoot.index.add((cid, DC.date, Literal(ts)))
                    print "loading: %s" % path, ts
                    redfoot.load(source, publicID=cid, creator=__uri__)

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="import">
    <rdfs:label>import</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[
    
KERNEL = redfoot.namespace("http://redfoot.net/3.0/kernel#")

from urllib import quote
from rdflib import Graph

uri = args[0]

g = Graph()
g.load(uri)

for context in g.subjects(RDF.type, KERNEL.Context):
    print context
    source = "%s?uri=%s" % (uri, quote(context))
    try:
        redfoot.load(source, publicID=context, creator=__uri__)
    except Exception, e:
        print e

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="copy">
    <rdfs:label>copy</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[
    
KERNEL = redfoot.namespace("http://redfoot.net/3.0/kernel#")

from urllib import quote
from rdflib import Graph

try:
    uri = args[0]
except:
    uri = None
    print "usage: <uri> [<prefix>]" # [<new_prefix>]

if uri:
      if len(args)>1:
          startswith = args[1]
      else:
          startswith = ''

      g = Graph()
      g.load(uri)

      for context_id in g.subjects(RDF.type, KERNEL.Context):
          if context_id.startswith(startswith):
              print "Copying:", context_id    
              context = redfoot.get_context(context_id, creator=__uri__)
              try:
                  context.load(context_id.concrete())
              except Exception, e:
                  print e

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="backup">
    <rdfs:label>backup</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[
    
import time, logging
from tarfile import open, TarInfo
try:
    from cStringIO import StringIO
except:
    from StringIO import StringIO
from urlparse import urlparse
from urllib import url2pathname
from rdflib.util import date_time
root = "backup-%s" % url2pathname(date_time().replace(":", "-"))
# one backup per day
#year, month, date, h, m, s, _, _, _ = time.gmtime()
#root = "backup-%04d-%02d-%02d" % (year, month, date)
tar = open("%s.tgz" % root, "w:gz")

DCTERMS = redfoot.namespace("http://purl.org/dc/terms/")

# usage backup all contexts starting with prefix (first arg)... defaults to all contexts
try:
    prefix = args[0]
except:
    prefix = ""

for context in redfoot.contexts():
    cid = context.identifier
    if cid.startswith(prefix):
        try:
            sio = StringIO(context.serialize())
        except Exception, e:
            sio = None
            print "Could not serialize %s: %s" % (cid, e)
        if sio:
            scheme, netloc, url, params, query, fragment = urlparse(cid)
            scheme = scheme or "_"
            netloc = netloc or "_"    
            if params or query:
                print "WARNING: params and query are being ignored"
            if fragment:
                url = "%s#%s" % (url, fragment)
            ti = TarInfo(str("%s/%s/%s/%s" % (root, scheme, netloc, url2pathname(url))))
            ti.size = len(sio.getvalue())
            # TODO: real last modified time
            ti.mtime = int(time.time())#redfoot.value(cid, DCTERMS.created)
            tar.addfile(ti, sio)
tar.close()


]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="restore">
    <rdfs:label>restore</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[
    
from rdflib.Graph import Graph
import time, logging
from tarfile import open, TarInfo
try:
    from cStringIO import StringIO
except:
    from StringIO import StringIO
from urlparse import urlunparse
from urllib import url2pathname

try:
    filename = args[0]
except:
    filename = None
    print "Usage: redfoot restore <filename>"

# TODO: don't clobber _index.
# TODO: option for things like not clobbering a context if it's newer than backup

if filename is not None:
    tar = open(filename, "r:gz")

    source_index = Graph()
    for name in tar.getnames():
        root, scheme, netloc, path = name.split("/", 3)
        if path=="_index":
            source_index.parse(tar.extractfile(tar.getmember(name)))
            break
    for tarinfo in tar:
        if tarinfo.isreg():
            root, scheme, netloc, path = tarinfo.name.split("/", 3)
            if scheme=="_":
                scheme = ""
            if netloc=="_":
                netloc = ""
            params = ""
            query = ""
            if "#" in path:
                path, fragment = path.split("#")
            else:
                fragment = ""
            url = urlunparse((scheme, netloc, path, params, query, fragment))
            if url=="_config" or url=="_index":
                continue
            if url.startswith("_"):
                context_id = BNode(url)
            else:
                if "#" in url:
                    publicID, frag = url.split("#")
                    frag = "#%s" % frag
                else:
                    publicID = url
                    frag = None
                context_id = redfoot.context_id(url, frag)
            print "loading:", context_id
            context = redfoot.get_context(context_id)
            if len(context)==0:
                # clear context metadata about context we just created
                # above when calling redfoot.get_context
                redfoot.index.remove((context_id, None, None)) 
                # copy context metadata from that in backup file
                for t in source_index.triples((context_id, None, None)):
                    redfoot.index.add(t)
                context.parse(tar.extractfile(tarinfo), publicID=publicID, preserve_bnode_ids=True)
            else:
                print "skipping: %s (already exists)" % url
        elif tarinfo.isdir():
            print "a directory."
        else:
            print "something else."
    tar.close()

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="remove">
    <rdfs:label>remove</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[
    
KERNEL = redfoot.namespace("http://redfoot.net/3.0/kernel#")

from urllib import quote
from rdflib import Graph
from itertools import chain

try:
    startswith = args[0]
except:
    startswith = None
    print "usage: [startswith]"

if startswith:
    # list is currently needed else not all will get removed due to
    # concurrency issues (removing while iterating over)
    for context in list(redfoot.contexts()):
        cid = context.identifier
        try:
            if cid.startswith(startswith):
                redfoot.write("Removing: %s\n" % cid)
                redfoot.remove_context(context)
                redfoot.index.remove((cid, None, None))
        except Exception, e:
            print e
    # clean up index
    for cid in list(redfoot.index.subjects(RDF.type, KERNEL.Context)):
        if cid.startswith(startswith):
            redfoot.write("Removing stale index info for: %s\n" % cid)
            redfoot.index.remove((cid, None, None))

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="rename">
    <rdfs:label>rename</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[
    
import logging

_logger = redfoot.getLogger(__uri__)

from rdflib import URIRef, BNode
from rdflib.Graph import Graph

OLD = args[0]
NEW = args[1]

nothing_renamed = True

# rename contexts
for context in list(redfoot.contexts()):
    if OLD in context.identifier:
        if isinstance(context.identifier, URIRef):
            identifier = URIRef(context.identifier.replace(OLD, NEW))
        elif isinstance(context.identifier, BNode):
            identifier = BNode(context.identifier.replace(OLD, NEW))
        else:
            _logger.warning("Unexpected identifier type. Skipping context '%s'" % context.identifier)
            continue
        new_context = Graph(store=redfoot.store, identifier=identifier, namespace_manager=redfoot)
        nothing_renamed = False
    else:
        new_context = context

    for s, p, o in context:
        ss, pp, oo = s, p, o
        if isinstance(s, URIRef) and OLD in s:
            ss = URIRef(s.replace(OLD, NEW))
        if isinstance(p, URIRef) and OLD in p:
            pp = URIRef(p.replace(OLD, NEW))
        if isinstance(o, URIRef) and OLD in o:
            oo = URIRef(o.replace(OLD, NEW))
        if (ss, pp, oo)!=(s, p, o) or context!=new_context:
            nothing_renamed = False
            context.remove((s, p, o))
            new_context.add((ss, pp, oo))

    if new_context!=context:
        redfoot.remove_context(context.identifier)

if nothing_renamed:
    _logger.warning("nothing renamed.")

]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="touch">
    <rdfs:label>touch</rdfs:label>
    <rdfs:comment>Modifies all SERVER.last_modified times to the current time.</rdfs:comment>
        <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[
    
SERVER = redfoot.namespace("http://redfoot.net/3.0/server#")

from time import time
now = Literal("%s" % time())

for (s, p, o), cg in redfoot.store.triples((None, SERVER.last_modified, None), None):
    for c in cg:
        c.remove((s, p, o))
        c.add((s, p, now))
]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="update">
    <rdfs:label>update</rdfs:label>
    <rdfs:comment>...</rdfs:comment>
        <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[

KERNEL = redfoot.namespace("http://redfoot.net/3.0/kernel#")
RDFE = redfoot.namespace("http://redfoot.net/3.0/rdf#")

for (s, p, o), cg in redfoot.store.triples((None, RDFE.context_id, None), None):
    for c in cg:
        c.remove((s, p, o))
        if (s, RDFE.publicID, None) not in redfoot:
            c.add((s, RDFE.publicID, o))
]]>
    </code:python>
  </command:Command>

  <command:Command rdf:ID="svn_auth">
    <rdfs:label>svn_auth</rdfs:label>
    <code:python rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
<![CDATA[

import logging

_logger = redfoot.getLogger(__uri__)

import sha, base64

USER = redfoot.namespace("http://redfoot.net/3.0/user#")

def b64(hexdigest):
    digest = base64.b16decode(hexdigest.upper())
    return base64.encodestring(digest)[:-1] # [:-1] to remove a newline

def identifier2username(uri):
    if "@" in uri:
        first = uri.split("@")[0]
        return first.replace("mailto:", "")
    if "/" in uri:
        last = uri.split("/")[-1]
        return last.replace("#", "")


for user in redfoot.subjects(RDF.type, USER.User):
    for hexdigest in redfoot.objects(user, USER.hexdigest):
        if len(hexdigest)==40: # sha
            username = identifier2username(user)
            print "%s:{SHA}%s" % (username, b64(hexdigest))
        else:
            _logger.debug("warning: could not generate right kind of digest for %s using %s" % (user, hexdigest))

]]>
    </code:python>
  </command:Command>

</rdf:RDF>  
