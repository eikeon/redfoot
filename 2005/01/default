<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
   xmlns:redfoot="http://redfoot.net/2005/redfoot#"
   xmlns:main="http://redfoot.net/2005/01/main#"
   xmlns:handler="http://redfoot.net/2005/01/handler#"
>

  <redfoot:Python rdf:ID="code">
    <rdfs:label>program for redfoot</rdfs:label>
    <redfoot:codestr>
<![CDATA[

REDFOOT = redfoot.namespace("http://redfoot.net/2005/redfoot#")
PROGRAM = redfoot.namespace("http://redfoot.net/2005/program#")

commands = {}

for config in redfoot.objects(redfoot.main, PROGRAM.config):
    if not (config, None, None) in redfoot:
        redfoot.load(config)

    for command in store.objects(config, PROGRAM.command):
        label = first(store.objects(command, RDFS.label))
        code = first(store.objects(command, REDFOOT.code))
        commands[label] = code

if not args:
    args = [""]
    print "available commands:",
    for command in commands.keys():
        print command,
    print ""
else:
    command = args[0]
    code = commands.get(command, None)
    redfoot.execute(code, args=args[1:])

]]>
    </redfoot:codestr>
  </redfoot:Python>

  <redfoot:Configuration rdf:ID="config">
    <main:command rdf:parseType="Resource">
      <rdfs:label>run</rdfs:label>
      <redfoot:code rdf:resource="http://redfoot.net/2005/01/default#Main"/>
    </main:command>
    <main:command rdf:parseType="Resource">
      <rdfs:label>load</rdfs:label>
      <redfoot:code rdf:resource="http://redfoot.net/2005/01/default#Load"/>
    </main:command>
    <main:command rdf:parseType="Resource">
      <rdfs:label>contexts</rdfs:label>
      <redfoot:code rdf:parseType="Resource">
        <rdfs:label>Default main for Redfoot</rdfs:label>      
        <redfoot:codestr>
<![CDATA[

from rdflib.InformationStore import SOURCE

for cid, _, source in store.triples((None, SOURCE, None)):
    print source, len(store.get_context(cid))

]]>
        </redfoot:codestr>
      </redfoot:code>
    </main:command>
    <main:command rdf:parseType="Resource">
      <rdfs:label>reload_all</rdfs:label>
      <redfoot:code rdf:parseType="Resource">
        <rdfs:label>Default main for Redfoot</rdfs:label>      
        <redfoot:codestr>
<![CDATA[

from rdflib.InformationStore import SOURCE

for cid, _, source in store.triples((None, SOURCE, None)):
    if source:
        print "loading %s" % source
        try:
            store.load(source)
        except Exception, e:
            print e

]]>
        </redfoot:codestr>
      </redfoot:code>
    </main:command>
    <main:command rdf:parseType="Resource">
      <rdfs:label>backup_recipes</rdfs:label>
      <redfoot:code rdf:parseType="Resource">
        <rdfs:label>Default main for Redfoot</rdfs:label>      
        <redfoot:codestr>
<![CDATA[

context = store.get_context(URIRef("http://donnafales.com/recipes/submitted_recipes"))
context.save("recipes-backup.rdf")

]]>
        </redfoot:codestr>
      </redfoot:code>
    </main:command>
    <main:command rdf:parseType="Resource">
      <rdfs:label>load_recipes</rdfs:label>
      <redfoot:code rdf:parseType="Resource">
        <rdfs:label>Default main for Redfoot</rdfs:label>      
        <redfoot:codestr>
<![CDATA[

context = store.get_context(URIRef("http://donnafales.com/recipes/submitted_recipes"))
context.load("recipes-backup.rdf")

]]>
        </redfoot:codestr>
      </redfoot:code>
    </main:command>
    <main:command rdf:parseType="Resource">
      <rdfs:label>sites</rdfs:label>
      <redfoot:code rdf:parseType="Resource">
        <rdfs:label>Default main for Redfoot</rdfs:label>      
        <redfoot:codestr>
<![CDATA[

RedfootServer = redfoot.module("http://redfoot.net/2005/01/default#server").RedfootServer
server = RedfootServer(store, port=8080)
server.run()

]]>
        </redfoot:codestr>
      </redfoot:code>
    </main:command>

    <!-- TODO: move to recipe schema -->
    <main:command rdf:parseType="Resource">
      <rdfs:label>submit_recipe</rdfs:label>
      <redfoot:code rdf:parseType="Resource">
        <rdfs:label>Default main for Redfoot</rdfs:label>      
        <redfoot:codestr>
<![CDATA[

RECIPE = store.namespace("http://donnafales.com/2002/07/28/recipe-schema#")

email = redfoot.module("http://eikco.com/2005/01/email#module")
message = email.parse()

if "@eikeon.com" in message.email_address:
    recipes = URIRef("http://eikeon.com/recipes/")
else:
    recipes = URIRef("http://donnafales.com/recipes/")    

recipe_uri = URIRef("%s%s/" % (recipes, message.subject))

# currently context where all recipes are stored
context = store.get_context(URIRef("http://donnafales.com/recipes/submitted_recipes"))

context.remove((None, RECIPE.recipe, recipe_uri))
context.add((recipes, RECIPE.recipe, recipe_uri))

recipe = redfoot.module("http://donnafales.com/2002/07/28/recipe-schema#module")
recipe.parse(message.payload, context, recipe_uri)


# Backup
from datetime import datetime
context.save("/var/www/redfoot2005/recipes-%s.rdf" % datetime.now().date())

]]>
        </redfoot:codestr>
      </redfoot:code>
    </main:command>

    <main:command rdf:parseType="Resource">
      <rdfs:label>remove_recipe</rdfs:label>
      <redfoot:code rdf:parseType="Resource">
        <rdfs:label>Default main for Redfoot</rdfs:label>      
        <redfoot:codestr>
<![CDATA[

def remove(r):
    for s, p, o in store.triples((r, None, None)):
        store.remove((s, p, o))
        if isinstance(o, BNode):
            remove(o)

for arg in args:
    uri = URIRef(arg)
    remove(uri)
    store.remove((None, None, uri))

]]>
        </redfoot:codestr>
      </redfoot:code>

    </main:command>

  </redfoot:Configuration>>

  <redfoot:Python rdf:ID="Main">
    <rdfs:label>default main</rdfs:label>      
    <redfoot:codestr>
<![CDATA[

RedfootServer = redfoot.module("http://redfoot.net/2005/01/default#server").RedfootServer
server = RedfootServer(store, port=9090)

server.run()

]]>
    </redfoot:codestr>
  </redfoot:Python>

  <redfoot:Python rdf:ID="Load">
    <rdfs:label>Default main for Redfoot</rdfs:label>      
    <redfoot:codestr>
<![CDATA[

for arg in args:
    print "loading: %s" % arg
    store.load(arg)

]]>
    </redfoot:codestr>
  </redfoot:Python>

  <redfoot:Python rdf:ID="handler">
    <rdfs:label>Default handler</rdfs:label>      
    <redfoot:codestr>
<![CDATA[

HANDLER = redfoot.namespace("http://redfoot.net/2005/01/handler#")
DEFAULT = redfoot.namespace("http://redfoot.net/2005/01/default#")

import kid
from StringIO import StringIO

def lookup(property):
    # TODO: generalize... with bit of looking at type like content currently does.
    p = first(store.objects(request.uri, property))
    if not p:
        p = first(store.objects(request.host, property))
    return p
    
from kid.util import XML

def display(uri, xml_decl=0, **args):
    # TODO: display could do lookup if uri is of python property
    if not uri:
        return
    assert(isinstance(uri, URIRef), "uri not URIRef as expected")
    redfoot.check(uri)
    s = first(store.objects(uri, HANDLER.kid))
    context = globals()
    for k, v in args.items():
        context[k] = v
    if s:
        t = kid.load_template(StringIO(s))
        t.write(response, xml_decl=xml_decl, **context)
    else:
        redfoot.execute(uri, **context) # TODO: is **globals still needed?


print "handler:", request.uri#, request.headers
    

def handle():
    content_type = request.parameters.get("content_type", None)
    if content_type=="text":
        text = first(store.objects(request.uri, HANDLER.text))
        if not text:
            print "???", request.uri            
            type = first(store.objects(request.uri, RDF.type))
            if type:
                text = first(store.objects(type, HANDLER.text))
        assert text, "No text found"
        response.setHeader('Content-Type', "text/plain")    
        #redfoot.execute(text, request=request, response=response)
        redfoot.execute(text, context=globals())        
        return

    page = first(store.objects(request.uri, HANDLER.page))
    if not page:
        page = first(store.objects(request.host, HANDLER.page))

    assert page, "No page found"

    content_type = first(store.objects(page, HANDLER.content_type)) or 'text/html; charset=UTF-8'
    response.setHeader('Content-Type', content_type)

    content = first(store.objects(request.uri, HANDLER.content))
    if not content:
        type = first(store.objects(request.uri, RDF.type))
        if type:
            content = first(store.objects(type, HANDLER.content))

    if content:
        # TODO: I'm assuming the status is initialized to a 200 already?
        display(page, xml_decl=1, content=content)
    else:
        if not (request.uri, None, None) in store: # TODO: move this more outer
            response.setStatus(404, "Not Found")            
            content = first(store.objects(request.host, HANDLER.not_found)) or DEFAULT.not_found
        display(page, xml_decl=1, content=content)

handle()        

]]>
    </redfoot:codestr>
  </redfoot:Python>

  <redfoot:Python rdf:ID="server">
    <rdfs:label>Default server for Redfoot</rdfs:label>      
    <redfoot:codestr>
<![CDATA[

# TODO: move into reusable module

try:
    from zope.server.serverbase import ServerBase
    from zope.server.http.httpserverchannel import HTTPServerChannel
except ImportError, e:
    print e
    print """\
Install either:
    ZopeX3 from http://zope.org/Products/ZopeX3
or
    Zope Interface from http://zope.org/Products/ZopeInterface
    cd ZopeInterface-3.0.0
    python setup.py install

    zope.server from http://zope.org/Products/ZopeX3
    cd ZopeX3-3.0.0/Dependencies/zope.server-ZopeX3-3.0.0/
    python setup.py install
    zope.server from the Dependencies
"""
from Cookie import SimpleCookie
from cgi import parse_qsl

ENCODING = "UTF-8"


class Request(object):
    def __init__(self, task):
        self.__task = task
        self.__cookies = None
        self.method = self.__task.request_data.command
        self.query_string = self.__task.request_data.query
        self.__parameters = None
	hostname = self.getHeader("host")
	path = self.__task.request_data.path
	self.url = URIRef("http://%s%s" % (hostname, path))
	self.host_url = URIRef("http://%s" % (hostname))

	hostname = hostname.split(":", 1)[0]
        self.uri = URIRef("http://%s%s" % (hostname, path))
	self.host = URIRef("http://%s" % (hostname)) 

        
    def getHeader(self, name):
        return self.__task.request_data.headers.get(name.upper(), None)

    def _getHeaders(self):
        return self.__task.request_data.headers
    
    headers = property(_getHeaders)

    def getCookie(self, name):
        if self.__cookies==None:
            cookies = {}
            text = self.getHeader("COOKIE")
            if text:
                c = SimpleCookie(text)
                for key, value in c.items():
                    cookies[unicode(key, ENCODING)] = unicode(value.value, ENCODING)
            self.__cookies = cookies
        return self.__cookies.get(name, None)

    def _getParameters(self):
        # TODO: make parameters read-only?
        if self.__parameters == None:
            self.__parameters = p =  {}
            q = self.query_string
            if q:
                for k, v in parse_qsl(q, keep_blank_values=1):
                    p[k] = v
        return self.__parameters

    parameters = property(_getParameters)


def toChunk(data):
    return ''.join(["%x\r\n" % len(data), data, "\r\n"])

class Response(object):
    def __init__(self, task):
        self.__task = task
        self.chunked = 1
        self.__task.response_headers['Transfer-Encoding'] = 'chunked'

    def setStatus(self, status, reason):
        self.__task.setResponseStatus(status, reason)

    def write(self, data):
        if isinstance(data, unicode):
            data = data.encode("UTF-8")
        if self.chunked:
            self.__task.write(toChunk(data))
        else:
            self.__task.write(data)

    def finish(self):
        if self.chunked:
            # write last chunk plus a closing CRLF
            self.__task.write("0\r\n\r\n")

    def setHeader(self, name, value):
        self.__task.response_headers[name] = value
        

from rdflib.URIRef import URIRef
from rdflib.BNode import BNode
from rdflib import RDF, RDFS
from rdflib.util import first


class HTTPServer(ServerBase):
    """This is a generic HTTP Server."""

    channel_class = HTTPServerChannel
    SERVER_IDENT = 'redfoot2005'

    def executeRequest(self, task):
        """Execute an HTTP request."""
        # This is a default implementation, meant to be overridden.
        self.handle(Request(task), Response(task))
        

SERVER = redfoot.namespace("http://redfoot.net/2005/01/server#")


class RedfootServer(object):

    def __init__(self, store, hostname='', port=9090):
        self.store = store
        from zope.server.taskthreads import ThreadedTaskDispatcher
        from zope.server.adjustments import Adjustments
        self.td = td = ThreadedTaskDispatcher()
        td.setThreadCount(8)
        adjustments = Adjustments()
        self.server = HTTPServer(hostname, port, task_dispatcher=td, adj=adjustments)
        self.server.handle = self.handle


    def run(self):
        try:
            import asyncore
            while 1:
                asyncore.poll(5)

        except KeyboardInterrupt:
            self.store.close()
            print 'shutting down...'
            self.td.shutdown()
        
    def handle(self, request, response):
        handlers = list(self.store.objects(request.uri, SERVER.handler))
        assert(len(handlers)<=1, "Shouldn't be more than one handler")
        if not handlers:
            handlers = list(self.store.objects(request.host, SERVER.handler))
        assert(len(handlers)<=1, "Shouldn't be more than one handler")
        if handlers:
            handler = handlers[0]
            self.store.execute(handler, request=request, response=response)
        else:
            response.setHeader('Content-Type', 'text/html; charset=UTF-8')            
            # TODO: rename to setStatus
            response.setStatus(404, "Not Found")
            response.write("""
<html>
<head>
<title>Not found</title>
</head>
<h1>Not Found</h1>
</html>
""")
        response.finish() # TODO: where should this go?

]]>
    </redfoot:codestr>
  </redfoot:Python>

  <redfoot:Python rdf:ID="page">
    <rdfs:label>Default page template</rdfs:label>
    <handler:kid>
<![CDATA[
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:kid="http://naeblis.cx/ns/kid#"> <!--TODO: the xml: prefix gets lost when
                                                       kid outputs this template
                                                 xml:lang="en"-->
  <head>
<?kid
#
title = store.label(request.uri)
type = first(store.objects(request.uri, RDF.type))
if type:
    title = "%s %s" % (title, store.label(type, ''))
?>

  <title>{store.label(request.host)}: {title}</title>
    <meta name="keywords" content=""/>
    <meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8"/>
    <link rel="shortcut icon" href="http://redfoot.net/2002/11/25/favicon.ico"/>
    <link rel="stylesheet" type="text/css" href="http://redfoot.net/2005/01/css" />
   <span kid:omit="" kid:for="alternate in store.objects(request.uri, HANDLER.alternate)">
    <link rel="alternate"
      href="{alternate}" title="{store.label(alternate)}"
      type="{first(store.objects(alternate, HANDLER.content_type))}" />
   </span> 
  </head>
  <body>

  <h1><a href="{request.host}/">{store.label(request.host)}</a></h1>

  <div class="header">
    {display(lookup(HANDLER.header))}
  </div>

    <div class="middle">
      <div class="content">
        {display(content)}
      </div>
    </div>

    <div class="footer">
      {display(lookup(HANDLER.footer))}
    </div>
  </body>
</html>
]]>
    </handler:kid>    
  </redfoot:Python>

  <redfoot:Python rdf:ID="not_found">
    <rdfs:label>Not Found</rdfs:label>
    <redfoot:codestr>
<![CDATA[

response.write("""
<h1>Not Found</h1>
""")        
    
]]>
    </redfoot:codestr>
  </redfoot:Python>

</rdf:RDF>  
